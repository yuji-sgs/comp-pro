"""
たかはし君は迷路が好きです。今、上下左右に移動できる二次元盤面上の迷路を解こうとしています。盤面は以下のような形式で与えられます。
まず、盤面のサイズと、迷路のスタート地点とゴール地点の座標が与えられる。
次に、それぞれのマスが通行可能な空きマス(.)か通行不可能な壁マス(#)かという情報を持った盤面が与えられる。盤面は壁マスで囲まれている。スタート地点とゴール地点は必ず空きマスであり、スタート地点からゴール地点へは、空きマスを辿って必ずたどり着ける。具体的には、入出力例を参考にすると良い。
今、彼は上記の迷路を解くのに必要な最小移動手数を求めたいと思っています。どうやって求めるかを調べていたところ、「幅優先探索」という手法が効率的であることを知りました。
さて、この処理をスマートに実装するためには、先入れ先出し(FIFO)のキュー(Queue)というデータ構造を用いると良いことが知られています。もちろん、使わなくても解くことは可能です。今回、よく分からなければ思いついた方法で解くことをおすすめします。先入れ先出しのキューとは以下のような機能を持つデータ構造です。
追加(Push): キューの末尾にデータを追加する。
取り出し(Pop): キューの先頭のデータを取り出す。
このデータ構造を使うと、先ほどの幅優先探索の説明における「マスの最短手数の確定」のタイミングでその確定マスをキューに追加し、追加操作が終わればPopを行い、取り出したマスの4近傍を調べるということを繰り返せば(つまり先に追加されたものから順番に処理していけば)、簡潔に処理ができることが分かります。
"""
from collections import deque

R, C = map(int, input().split())
sy, sx = map(int, input().split())
gy, gx = map(int, input().split())

# インデックスを0スタートで扱うために1を引く
sy -= 1
sx -= 1
gy -= 1
gx -= 1

# 迷路の入力
grid = [input() for _ in range(R)]

# 最初にスタート地点をキューに入れる
q = deque()
q.append((sy, sx))

# スタートから各マスまでの最短距離を管理する2次元配列
INF = 10 ** 9
dist = [[INF for _ in range(C)] for _ in range(R)]
dist[sy][sx] = 0

# 4方向への移動ベクトル
dy = (1, 0, -1, 0)
dx = (0, 1, 0, -1)

# 幅優先探索
while len(q) > 0: # キューが空になるまで繰り返す
    
    # キューの先頭を取り出す
    now = q.popleft()
    
    # 取り出したキューのy, x座標を定義
    y, x = now
    
    # 隣接する4マスを探索
    for di in range(4):
        
        # 移動した後の点を (ny, nx) とする
        ny = y + dy[di]
        nx = x + dx[di]
        
        # 移動が可能かの判定と既に訪れたことがあるかの判定
        if ny < 0 or ny >= R or nx < 0 or nx >= C:
            continue
        if grid[ny][nx] == "#":
            continue
        if dist[ny][nx] != INF:
            continue
        
        # 移動できるならキューに入れ、その点の距離を更新
        dist[ny][nx] = dist[y][x] + 1
        q.append((ny, nx))
        
print(dist[gy][gx])
